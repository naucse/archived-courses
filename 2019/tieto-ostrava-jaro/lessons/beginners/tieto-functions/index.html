<h2>Abstraction - Functions</h2>
<p>In Python, function is a group of related statements that perform a specific task.</p>
<p>Functions help break our program into smaller and modular chunks. As our program grows larger and larger, functions make it more organized and manageable.</p>
<p>Furthermore, it avoids repetition and makes code reusable.</p>
<p>A function is something you can call (optionally with some parameters). Function is providing some action and returns some value.</p>
<p>In Python we can declare function like this:</p>
<div class="highlight"><pre><code>def name(parameter1, parameter2,...):
    body</code></pre></div><p>Simple example:</p>
<div class="highlight"><pre><code>def hello(name):
     return 'Hello, ' + name + '!'</code></pre></div><p>Function hello returns string with a greeting and name given as a parameter.
We can call this function like this:</p>
<div class="highlight"><pre><code>&gt;&gt;&gt; print(hello('world'))
Hello, world!
&gt;&gt;&gt; print(hello('Peter'))
Hello, Peter!</code></pre></div><h3>Documenting functions</h3>
<p>You should document your functions, so you (or others!) will later understand, what is the purpose of the functon, which parameters areaccepting and what value returns.</p>
<p>How to document functions? If you put the documentation string on the line below the function declaration, you will create so called <em>docstring</em>.</p>
<div class="highlight"><pre><code>def multiple(x):
    'Multiplication of the number x.'
    return x * x</code></pre></div><p>You can then access the documentation of the function like this:</p>
<div class="highlight"><pre><code>&gt;&gt;&gt; def multiple(x):
...     'Multiplication of the number x.'
...     return x * x
...
&gt;&gt;&gt; multiple.__doc__
'Multiplication of the number x.'</code></pre></div><div class="admonition note"><p class="admonition-title">__doc__ is a function attribute.</p>
</div><h3>The return statement</h3>
<p>The return statement is used to exit a function and go back to the place from where it was called.</p>
<p>Syntax:</p>
<div class="highlight"><pre><code>return [expression_list]</code></pre></div><h3>Types of Functions</h3>
<p><strong>Build-in</strong></p>
<p>chr()   -   Returns a Character (a string) from an Integer</p>
<p>dict()  -   Creates a Dictionary
...</p>
<p><strong>User-defined</strong></p>
<p>User-Defined Functions (UDFs). All the other functions that we write on our own fall under user-defined functions. So, our user-defined function could be a library function to someone else.</p>
<p><strong>Anonymous functions</strong></p>
<p>Also called lambda functions, because they are not declared with the standard def keyword.</p>
<h3>Parameters</h3>
<p>Your function should do its job with supplied (correct) parameters and fails if the parameters are wrong.</p>
<p>Assigning a new value to a parameter inside a function won't change the outside code.</p>
<div class="highlight"><pre><code>&gt;&gt;&gt; def try_change_variable(n):
...  n = 'Hello World'
...
&gt;&gt;&gt; name = 'Hello Tieto'
&gt;&gt;&gt; try_change_variable(name)
&gt;&gt;&gt; name
'Hello Tieto'</code></pre></div><div class="admonition note"><p class="admonition-title">Parameters are in *local scope*.</p>
</div><div class="admonition warning"><p class="admonition-title">Please be careful about changing mutable data structure:</p>
<div class="highlight"><pre><code>&gt;&gt;&gt; def change(n):
...  n[0] = 'Mr. Foo'
...
&gt;&gt;&gt; names = ['Mr. Bar', 'Mr. Baz']
&gt;&gt;&gt; change(names)
&gt;&gt;&gt; names
['Mr. Foo', 'Mr. Baz']</code></pre></div></div><p><strong>There are four types of arguments that Python UDFs can take:</strong></p>
<ul>
<li>Default arguments</li>
<li>Required arguments</li>
<li>Keyword arguments</li>
<li>Variable number of arguments</li>
</ul>
<h4>Default arguments</h4>
<p>Default arguments are those that take a default value if no argument value is passed during the function call. You can assign this default value by with the assignment operator =, just like in the following example:</p>
<div class="highlight"><pre><code>def plus(a, b=2):
  return a + b

# Call `plus()` with only `a` parameter
plus(a=1)

# Call `plus()` with `a` and `b` parameters
plus(a=1, b=3)</code></pre></div><h4>Required arguments</h4>
<p>The required arguments of a UDF are those that have to be in there. These arguments need to be passed during the function call and in exactly the right order, just like in the following example:</p>
<div class="highlight"><pre><code>def plus(a, b):
  return a/b</code></pre></div><h4>Keyword Arguments</h4>
<p>If you want to make sure that you call all the parameters in the right order, you can use the keyword arguments in your function call. You use these to identify the arguments by their parameter name.</p>
<div class="highlight"><pre><code>def  hello_1(greeting, name):
     print('{}, {}!'.format(greeting, name))</code></pre></div><div class="highlight"><pre><code>&gt;&gt;&gt; hello_1(greeting='Hello', name='world')
Hello, world!
&gt;&gt;&gt; hello_1(name='world', greeting="Hello")
Hello, world!</code></pre></div><h3>Variable Number of Arguments</h3>
<p>In cases where you donâ€™t know the exact number of arguments that you want to pass to a function, you can use the following syntax with *args:</p>
<div class="highlight"><pre><code># Define `plus()` function to accept a variable number of arguments
def plus(*args):
  return sum(args)

# Calculate the sum
&gt;&gt;&gt; plus(1,4,5)
10</code></pre></div><h3>Usage of *args</h3>
<p><em>args and **kwargs are mostly used in function definitions. </em>args and *<em>kwargs allow you to pass a variable number of arguments to a function. What does variable mean here is that you do not know before hand that how many arguments can be passed to your function by the user so in this case you use these two keywords. </em>args is used to send a non-keyworded variable length argument list to the function.</p>
<div class="highlight"><pre><code>def test_var_args(f_arg, *argv):
    print "first normal arg:", f_arg
    for arg in argv:
        print "another arg through *argv :", arg

test_var_args('yasoob','python','eggs','test')</code></pre></div><div class="highlight"><pre><code>first normal arg: yasoob
another arg through *argv : python
another arg through *argv : eggs
another arg through *argv : test</code></pre></div><h3>Usage of **kwargs</h3>
<p>**kwargs allows you to pass keyworded variable length of arguments to a function. You should use **kwargs if you want to handle named arguments in a function.</p>
<div class="highlight"><pre><code>def greet_me(**kwargs):
    if kwargs is not None:
        for key, value in kwargs.iteritems():
            print("%s == %s" %(key,value))</code></pre></div><div class="highlight"><pre><code>&gt;&gt;&gt; greet_me(name="yasoob")
name == yasoob</code></pre></div><h3>Global vs Local Variables</h3>
<p>In general, variables that are defined inside a function body have a local scope, and those defined outside have a global scope. That means that local variables are defined within a function block and can only be accessed inside that function, while global variables can be accessed by all functions that might be in your script:</p>
<div class="highlight"><pre><code># Global variable `init`
init = 1

# Define `plus()` function to accept a variable number of arguments
def plus(*args):
  # Local variable `sum()`
  total = 0
  for i in args:
    total += i
  return total

# Access the global variable
print("this is the initialized value " + str(init))

# (Try to) access the local variable
print("this is the sum " + str(total))</code></pre></div><h3>Anonymous Functions</h3>
<p>Anonymous functions are also called lambda functions in Python because instead of declaring them with the standard def keyword, you use the lambda keyword.</p>
<div class="highlight"><pre><code>double = lambda x: x*2

double(5)</code></pre></div><p>Another example of lambda function:</p>
<div class="highlight"><pre><code># `sum()` lambda function
sum = lambda x, y: x + y;

# Call the `sum()` anonymous function
sum(4,5)

# UDF equivalent
def sum(x, y):
  return x+y</code></pre></div><h4>Using main() as a Function</h4>
<p>In many programming languages, main function is required in order to execute functions. Not in Python, but you might want to write code like this:</p>
<div class="highlight"><pre><code># Define `main()` function
def main():
  hello()
  print("This is a main function")

# Execute `main()` function 
if __name__ == '__main__':
    main()</code></pre></div>