<h1>Další kombinace příkazů</h1>
<p>Už víš, že pomocí „roury“ (<code>|</code>) se dá poslat výstup z jednoho příkazu
do druhého.
Existuje ale několik dalších příkazů, kterými se v Bashi dají příkazy
kombinovat.</p>
<p>Nejjednodušší je středník (<code>;</code>): Bash napřed provede příkaz na levé straně,
počká až se dokončí, a potom spustí ten na pravé.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">echo</span> <span class="s1">&#39;Vysledek je&#39;</span><span class="p">;</span> python -c <span class="s1">&#39;print(1 + 1)&#39;</span>
<span class="go">Vysledek je</span>
<span class="go">2</span>
</pre></div><p>Docela užitečný operátor je <code>&amp;&amp;</code> (logické A; angl. <em>AND</em>): napřed se provede
příkaz na levé straně a počká se na výsledek.
Příkaz na pravé straně se provede pouze pokud první příkaz uspěl.
To že příkaz „uspěl“ znamená, že vrátil návratovou hodnotu 0.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>python -c <span class="s1">&#39;print(1 + )&#39;</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">&#39;je výsledek&#39;</span>
<span class="go">  File &quot;&lt;string&gt;&quot;, line 1</span>
<span class="go">    print(1 + )</span>
<span class="go">              ^</span>
<span class="go">SyntaxError: invalid syntax</span>
</pre></div><p>Tenhle operátor se hodí např. v případech, kdy píšeš program který připraví
nějaký soubor. Příkaz <code>python priprav-soubor.py &amp;&amp; head pripraveny-soubor.dat</code>
vypíše ukázku výsledku, ale jen když se všechno povedlo.
Když Python skončí s chybou, může existovat stará verze <code>pripraveny-soubor.dat</code>
z minulého spuštění.
Ale nevypíše se a na obrazovce zůstane chybová hláška od Pythonu.</p>
<p>Opak je <code>||</code> (logické NEBO; angl. <em>OR</em>): příkaz na pravé straně se provede,
pokud příkaz nalevo <em>neuspěl</em> (<code>$?</code> není 0).</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>python -c <span class="s1">&#39;print(1 + )&#39;</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s1">&#39;Jejda! Chyba!&#39;</span>
<span class="go">  File &quot;&lt;string&gt;&quot;, line 1</span>
<span class="go">    print(1 + )</span>
<span class="go">              ^</span>
<span class="go">SyntaxError: invalid syntax</span>
<span class="go">Jejda! Chyba!</span>
</pre></div><h2>Spouštění na pozadí</h2>
<p>A nakonec, když dáš za příkaz <code>&amp;</code>, tak Bash nebude čekat na konec programu,
ale pokračuje hned dál.
Když program skončí, dá Bash před dalším promptem vědět.</p>
<p>Hezky se to zkouší na příkazu <code>sleep</code>, který čeká daný počet vteřin:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>sleep <span class="m">1</span>
<span class="gp">$ </span>sleep <span class="m">1</span> <span class="p">&amp;</span>
<span class="go">[1] 25507</span>
<span class="gp">$
</span><span class="gp">$ </span><span class="c1"># vteřinu počkej...</span>
<span class="go">[1]+  Dokončena              sleep 1</span>
<span class="gp">$
</span></pre></div><p>Pozor na to, že program „v pozadí“ sdílí s Bashem terminál,
takže pokud bude něco psát na std. výstupů, bude se s Bashem „hádat“.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>curl https://httpbin.org/get <span class="p">&amp;</span>
<span class="go">[1] 25537</span>
<span class="gp">$ </span><span class="o">{</span> ... sem curl vypíše jakási stažená JSON data ...  <span class="o">}</span>
</pre></div><p>Programy běžící na pozadí můžeš vypsat pomocí <code>jobs</code>.
U každého vypíše malé číslo, pomocí kterého se taková „úloha“ (angl. <em>job</em>)
dá ovládat:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>sleep <span class="m">200</span> <span class="p">&amp;</span>
<span class="go">[1] 34696</span>
<span class="gp">$ </span>sleep <span class="m">300</span> <span class="p">&amp;</span>
<span class="go">[2] 34701</span>
<span class="gp">$ </span>sleep <span class="m">400</span> <span class="p">&amp;</span>
<span class="go">[3] 34706</span>
<span class="gp">$ </span><span class="nb">jobs</span>
<span class="go">[1]   Běží                 sleep 20 &amp;</span>
<span class="go">[2]-  Běží                 sleep 30 &amp;</span>
<span class="go">[3]+  Běží                 sleep 40 &amp;</span>
</pre></div><p>Úloha nemusí být vždy jen jednotlivý proces:</p>
<div class="highlight"><pre><code>$ sleep 500 &amp;&amp; sleep 600 &amp;
[4] 34846
$ jobs
[1]   Běží                 sleep 20 &amp;
[2]   Běží                 sleep 30 &amp;
[3]-  Běží                 sleep 40 &amp;
[4]+  Běží                 sleep 4 &amp;&amp; sleep 5 &amp;</code></pre></div><p>Úlohu který běží na pozadí lze popředí pomocí příkazu <code>fg</code>
(z angl. <em>foreground</em>, popředí);
kterému předáš číslo úlohy za procentem (<code>%</code>):</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">fg</span> %1
<span class="go">sleep 200</span>
</pre></div><p>Úlohu běžící na popředí – tu, na kterou Bash právě čeká – můžeš
zastavit pomocí <kbd>Ctrl</kbd>+<kbd>Z</kbd>:</p>
<div class="highlight"><pre><span></span><span class="go">^Z</span>
<span class="go">[1]+  Pozastavena             sleep 200</span>
<span class="gp">$ </span><span class="nb">jobs</span>
<span class="go">[1]+  Pozastavena             sleep 200</span>
<span class="go">[2]   Běží                 sleep 300 &amp;</span>
<span class="go">[3]   Běží                 sleep 400 &amp;</span>
<span class="go">[4]-  Běží                 sleep 500 &amp;&amp; sleep 600 &amp;</span>
</pre></div><p>Pozastavená úloha neběží.
Můžeš ji ale odpauzovat buď příkazem <code>fg</code>, který ji dá na popředí (tj. Bash
bude čekat než se ukončí).
Nebo ji můžeš spustit na pozadí příkazem <code>bg</code> (z angl. <em>background</em>, pozadí),
Po tom bude úloha ve stejném stavu jako kdybys ji spustila s <code>&amp;</code>.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">bg</span> %1
<span class="go">[1]+ sleep 200 &amp;</span>
<span class="gp">$ </span><span class="nb">jobs</span>
<span class="go">[1]+  Běží                 sleep 200</span>
<span class="go">[2]   Běží                 sleep 300 &amp;</span>
<span class="go">[3]   Běží                 sleep 400 &amp;</span>
<span class="go">[4]-  Běží                 sleep 500 &amp;&amp; sleep 600 &amp;</span>
</pre></div><p>Argumentům s procentem rozumí i příkaz <code>kill</code>, který danou úlohu ukončí:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">kill</span> %4
<span class="go">[4]+  Ukončen (SIGTERM)      sleep 500 &amp;&amp; sleep 600</span>
</pre></div><p>Když zadáš příkazu <code>fg</code> nebo <code>bg</code> bez argumentu, vybere „poslední“ úlohu.
Ta je ve výstupu <code>jobs</code> označena plusem.</p>
<p>Existují i další zkratky, např.:</p>
<ul>
<li><code>%+</code> a <code>%%</code> vyberou „poslední“ úlohu – tu označenou plusem.</li>
<li><code>%-</code> vybere a „předposlední“ úlohu – tu označenou minusem.</li>
<li><code>%abcd</code> vybere úlohu spuštěnou příkazem začínajícím na <code>abcd</code> (pokud
je spuštěna  právě jedna taková úloha).</li>
</ul>