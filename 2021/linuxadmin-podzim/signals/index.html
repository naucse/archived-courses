<div class="admonition warning"><p>Tohle jsou jen poznámky, ne materiály k samostudiu.</p>
</div><h1>Signály</h1>
<p>Signál (angl. <em>signal</em>) je způsob, jak poslat „upozornění“ běžícímu procesu.
I když ten proces zrovna dělá něco jiného, může na signál zareagovat.
Vlastně, jak si ukážeme, na signál zareagovat <em>musí</em>.</p>
<p>Signály jsou docela minimalistické: obsahují jen jedno malé číslo,
druh signálu.
Větší „zprávy“ se musí procesům posílat jiným způsobem (třeba souborem,
rourou nebo přes síť), ale i v těchto případech se dá signálem upozornit
že si proces má nějakou větší zprávu přečíst.
Například <code>httpd</code> čte konfiguraci ze spousty souborů,
ale signálem se dá přimět, aby je všechny načetl znova.
Příkaz <code>systemctl reload httpd</code> dělá právě tohle: pošle HTTP serveru signál.</p>
<h2>Přijetí signálu</h2>
<p>Když procesu pošleš signál, tak ten proces <em>přeruší</em> to co zrovna dělá
a signál zpracuje.
Co přesně se stane závisí na druhu signálu; možnosti jsou tyto:</p>
<ul>
<li>Ukončení (angl. <em>terminate</em>): proces se ukončí.</li>
<li>Ignorování (angl. <em>ignore</em>): nic se nestane.</li>
<li>Ukončení s chybou (angl. <em>core dump</em>): proces se ukončí. Pokud je na to
systém nastaven, stav paměti ukončeného procesu se zapíše do speciálního
souboru, aby bylo jednodušší zjistit co se v momentě ukončení zrovna dělo.</li>
<li>Pozastavení (angl. <em>stop</em>): Proces se pozastaví.
V shellu tohle dělá zkratka <kbd>Ctrl</kbd>+<kbd>Z</kbd></li>
<li>Obnovení (angl. <em>continue</em>): Pozastavený proces se znovu spustí.</li>
<li>Zachycení (angl. <em>catch</em>): Po přijetí signálu se zavolá funkce,
kterou proces nastavil.</li>
</ul>
<p>Když se proces na signály předem nepřipraví, provede se nějaká výchozí akce.
Ta závisí na druhu signálu, ale nejčastější jsou první dvě: proces se ukončí.</p>
<h2>Druhy signálů</h2>
<p>Každý druh signálu má své číslo a zkratkovité jméno.
Jejich seznam najdeš v manuálové stránce <code>signal(7)</code>, pomocí příkazu:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>man <span class="m">7</span> signal
</pre></div><div class="admonition note"><p>Pozor, <code>man signal</code> zobrazí stránku <code>signal(2)</code> – nápovědu pro funkci
<code>signal</code>, nikoli signály obecně.
To číslo je číslo „sekce“ manuálu; seznam sekcí najdeš v <code>man man</code>.</p>
</div><p>Každý signál má i své číslo, které se ale může na různých systémech
a procesorech lišit.
Lepší je proto používat jména – snad kromě čísla 9 pro <code>SIGKILL</code>.</p>
<h2>Posílání signálů</h2>
<p>Příkaz na posílání signálů už znáš: je to <code>kill</code>.
Přepínačem pojmenovaným podle signálu můžeš vybrat, který signál pošleš.</p>
<p>Zkus si to!</p>
<p>V jedom terminálu zadej:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>sleep <span class="m">1000</span>
</pre></div><p>A ve druhém třeba:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>ls -a <span class="p">|</span> grep sleep
<span class="go"> 12345678 pts/3   00:00:00 sleep</span>
<span class="gp">$ </span><span class="nb">kill</span> -SIGABRT <span class="m">12345678</span>
</pre></div><p>Signál <code>SIGABRT</code> proces dostane když se snaží provést neplatnou operaci –
instrukci, které procesor nerozumí.
To je většinou hodně závažná chyba.
Kdybys při instalaci systému zadala „automatické hlášení chyb“,
už by k vývojářům Fedory putovalo hlášení o tom, že v <code>/usr/bin/sleep</code>
z balíčku <code>coreutils</code> je chyba.
Pravděpodobně takhle ale virtuálku nastavenou nemáš, ale můžeš se aspoň
pomocí <code>abrt-cli list</code> podívat, že chyba byla zaznamenána.</p>
<p>Podobně si můžeš vyzkoušet jiné signály, třeba:</p>
<ul>
<li><code>SIGINT</code> se posílá když zmáčkneš <kbd>Ctrl</kbd>+<kbd>C</kbd>.</li>
<li><code>SIGTERM</code> posílá <code>kill</code> když mu nezadáš jiný signál.</li>
<li><code>SIGKILL</code> (9) se posílá když zmáčkneš <kbd>Ctrl</kbd>+<kbd>\</kbd>;
proces se „natvrdo“ ukončí.
U tohoto signálu si procesy nemůžou nastavit jiné chování:
proces se vždy ukončí.</li>
<li><code>SIGSTOP</code> se posílá když zmáčkneš <kbd>Ctrl</kbd>+<kbd>z</kbd>;
proces se pozastaví.
Podobně jako u <code>SIGKILL</code> si i u tohoto signálu si procesy nemůžou nastavit
jiné chování.</li>
<li><code>SIGCONT</code> posílá příkaz <code>fg</code>; pozastavený proces se obnoví.</li>
</ul>
<h2>Signály v Pythonu</h2>
<p>To, že se přijetí signálu přeruší cokoli co proces zrovna dělá,
se dá přirovnat k výjimkám v Pythonu.
Koneckonců, výjimka <code>KeyboardInterrupt</code> je jen reakce Pythonu na signál
<code>SIGINT</code>: vzniká tak, že so Python na <code>SIGINT</code> připravil: řekl operačnímu
systému že pro <code>SIGINT</code> nemá ukončit proces,
ale má se zavolat funkce která způsobí výjimku.</p>
<p>Program v Pythonu můžeš „připravit“ na výjimky pomocí <code>try</code> a <code>except</code>.
Na to, aby se program připravil na přijetí signálu, slouží funkce
<code>signal</code> z modulu <code>signal</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Moje PID:&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">sig_number</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Dostal jsem signál </span><span class="si">{</span><span class="n">sig_number</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">signal</span><span class="o">.</span><span class="n">strsignal</span><span class="p">(</span><span class="n">sig_number</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
<span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGUSR2</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
<span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div><p>Tento program reaguje na <code>SIGUSR1</code> a <code>SIGUSR2</code>, tedy např. <code>kill -SIGUSR1 $pid</code>.</p>
<p>Můžeš si ověřit, že pro <code>SIGKILL</code> a <code>SIGSTOP</code> funkce <code>signal.signal</code> selže.
A taky že předefinování <code>SIGINT</code> přenastaví chování
<kbd>Ctrl</kbd>+<kbd>C</kbd> – právě pro takové situace se hodí <code>SIGKILL</code>.</p>
<h2>Signály a démoni</h2>
<p>Démoni systémových služeb často reagují na signály.
Když se podíváš na <code>systemctl cat httpd</code> a <code>systemctl cat sshd</code>,
uvidíš řádky jako:</p>
<ul>
<li><code>KillSignal=SIGWINCH</code> – služba se ukončuje (<code>stop</code>) pomocí signálu
<code>SIGWINCH</code>, po kterém se server ukončí „elegantně“: přestane přijímat
nová spojení, ta co jsou otevřená zpracuje, a až potom se ukončí.</li>
<li><code>ExecReload=/usr/sbin/httpd $OPTIONS -k graceful</code> – tady se pro <code>reload</code>
volá speciální příkaz, který ale ve výsledku nedělá nic moc jiného než
poslání signálu <code>SIGUSR1</code>.
Když server tenhle signál dostane, dokončí otevřená spojení, ale mezitím
znovu načte konfiguraci a nová spojení začne zpracovávat s novým nastavením.</li>
<li><code>ExecReload=/bin/kill -HUP $MAINPID</code> – pro <code>reload</code> tohoto serveru se pošle
signál <code>SIGHUP</code>, který server interpretuje jako žádost o to, aby znovu načetl
nastavení.</li>
</ul>
<p>Co dělá který signál, to se dozvíš v dokumentaci konkrétního serveru.
Signálů je málo, a tak se často „zneužívají“ – třeba <code>SIGWINCH</code> by se formálně
měl posílat když se změní velikost terminálu; programy jako <code>nano</code> nebo
<code>top</code> si po jeho přijetí zjistí novou velikost a překreslí výstup.
Ale Apache <code>httpd</code> ho používá pro ukončení.</p>